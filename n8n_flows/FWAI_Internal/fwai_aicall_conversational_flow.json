{
  "name": "FWAI AI Call - Conversational Flow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "conv-start-call",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "trigger-start-call",
      "name": "Start Call Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "conv-start-call"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://34.93.142.172:3001/call/conversational",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  \"phoneNumber\": $json.body.phoneNumber,\n  \"contactName\": $json.body.contactName || \"Customer\",\n  \"n8nWebhookUrl\": \"https://n8n.srv1100770.hstgr.cloud/webhook/conv-transcript\",\n  \"callEndWebhookUrl\": \"https://n8n.srv1100770.hstgr.cloud/webhook/conv-call-ended\",\n  \"context\": {\n    \"customer_name\": $json.body.contactName || \"Customer\",\n    \"lead_source\": $json.body.leadSource || \"masterclass\"\n  }\n}) }}",
        "options": {}
      },
      "id": "start-conversational-call",
      "name": "Start Conversational Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "respond-start",
      "name": "Respond - Call Started",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [680, 300]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "conv-transcript",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "transcript-webhook",
      "name": "Transcript Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 520],
      "webhookId": "conv-transcript"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "user-speech",
              "leftValue": "={{ $json.body.role }}",
              "rightValue": "user",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "filter-user-speech",
      "name": "Filter User Speech",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [460, 520]
    },
    {
      "parameters": {
        "jsCode": "// FWAI Conversational Flow - Enhanced State Machine\n// Based on analysis of real sales call patterns\n\nconst text = $input.first().json.body.text.toLowerCase();\nconst callId = $input.first().json.body.call_uuid;\n\n// Get current state from static data\nconst staticData = $getWorkflowStaticData('global');\nconst callStates = staticData.callStates || {};\nconst currentState = callStates[callId] || { \n  phase: 'opening', \n  data: {},\n  turn_count: 0,\n  sentiment: 'neutral',\n  domain: null,\n  objections_handled: []\n};\n\ncurrentState.turn_count++;\nlet nextPhase = null;\nlet capturedData = currentState.data || {};\nlet contextToInject = '';\n\n// ============ DOMAIN DETECTION ============\nfunction detectDomain(text) {\n  const domains = {\n    'finance': ['finance', 'fp&a', 'accounting', 'banking', 'investment', 'financial', 'analyst', 'accounts', 'ca ', 'chartered'],\n    'it': ['developer', 'software', 'engineer', 'programming', 'coding', 'python', 'java', 'frontend', 'backend', 'fullstack', 'data science', 'machine learning', 'devops', 'bca', 'mca', 'btech', 'cse'],\n    'marketing': ['marketing', 'digital marketing', 'seo', 'social media', 'content', 'brand', 'advertising', 'ads'],\n    'student': ['student', 'studying', 'college', 'university', 'degree', 'pursuing', 'final year', 'fresher', 'graduate'],\n    'education': ['teacher', 'professor', 'lecturer', 'teaching', 'b.ed', 'bed', 'education']\n  };\n  \n  for (const [domain, keywords] of Object.entries(domains)) {\n    for (const keyword of keywords) {\n      if (text.includes(keyword)) {\n        return domain;\n      }\n    }\n  }\n  return null;\n}\n\n// ============ DOMAIN-SPECIFIC TOOLS ============\nconst domainTools = {\n  'finance': ['DataRails', 'Pigment', 'Planful', 'Cube Software', 'Vena'],\n  'it': ['GitHub Copilot', 'Cursor', 'Claude', 'LangChain', 'OpenAI API'],\n  'marketing': ['Canva AI', 'InVideo', 'Jasper', 'Copy.ai', 'AdCreative.ai'],\n  'student': ['ChatGPT', 'Claude', 'Notion AI', 'Grammarly'],\n  'education': ['Canva for Education', 'Quizlet AI', 'Notion AI']\n};\n\n// ============ EXPERIENCE EXTRACTION ============\nfunction extractExperience(text) {\n  const patterns = [\n    /(\\d+)\\s*(?:years?|yrs?)\\s*(?:of)?\\s*(?:experience)?/i,\n    /(?:experience|exp)\\s*(?:of)?\\s*(\\d+)\\s*(?:years?|yrs?)/i,\n    /(?:working|worked)\\s*(?:for)?\\s*(\\d+)\\s*(?:years?|yrs?)/i,\n    /(\\d+)\\s*(?:months?)\\s*(?:experience)?/i\n  ];\n  \n  for (const pattern of patterns) {\n    const match = text.match(pattern);\n    if (match) {\n      const num = parseInt(match[1]);\n      // If months mentioned, convert to years\n      if (text.includes('month')) {\n        return { years: Math.round(num / 12 * 10) / 10, raw: text };\n      }\n      return { years: num, raw: text };\n    }\n  }\n  return null;\n}\n\n// ============ SENTIMENT TRACKING ============\nfunction analyzeSentiment(text, currentSentiment) {\n  const positive = ['yes', 'great', 'good', 'interested', 'sure', 'okay', 'sounds good', 'amazing', 'love', 'excited', 'definitely'];\n  const negative = ['no', 'not interested', 'busy', 'later', 'bye', 'expensive', 'can\\'t', 'won\\'t', 'difficult'];\n  const hesitant = ['maybe', 'think', 'not sure', 'let me', 'need to', 'have to ask', 'discuss', 'decide'];\n  \n  let score = currentSentiment === 'positive' ? 1 : (currentSentiment === 'negative' ? -1 : 0);\n  \n  for (const word of positive) {\n    if (text.includes(word)) score += 0.5;\n  }\n  for (const word of negative) {\n    if (text.includes(word)) score -= 0.5;\n  }\n  for (const word of hesitant) {\n    if (text.includes(word)) score -= 0.2;\n  }\n  \n  if (score > 0.5) return 'positive';\n  if (score < -0.5) return 'negative';\n  return 'neutral';\n}\n\n// Update sentiment\ncurrentState.sentiment = analyzeSentiment(text, currentState.sentiment);\n\n// ============ OBJECTION DETECTION (Priority) ============\n// Check objections FIRST as they can happen at any phase\n\n// Objection: Need to discuss with family\nif ((text.includes('father') || text.includes('mother') || text.includes('parent') || text.includes('family') || text.includes('husband') || text.includes('wife') || text.includes('sister') || text.includes('brother')) && \n    (text.includes('ask') || text.includes('discuss') || text.includes('talk') || text.includes('tell'))) {\n  if (!currentState.objections_handled.includes('family')) {\n    nextPhase = 'objection_family';\n    currentState.objections_handled.push('family');\n  }\n}\n// Objection: Have exams\nelse if (text.includes('exam') || text.includes('test') || text.includes('semester')) {\n  if (!currentState.objections_handled.includes('exams')) {\n    nextPhase = 'objection_exams';\n    capturedData.has_exams = true;\n    // Try to extract exam dates\n    const dateMatch = text.match(/(\\d{1,2})(?:st|nd|rd|th)?\\s*(?:of)?\\s*(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i);\n    if (dateMatch) {\n      capturedData.exam_end_date = dateMatch[0];\n    }\n    currentState.objections_handled.push('exams');\n  }\n}\n// Objection: Need time to decide\nelse if ((text.includes('time') || text.includes('decide') || text.includes('think')) && \n         (text.includes('give me') || text.includes('need') || text.includes('let me') || text.includes('some'))) {\n  if (!currentState.objections_handled.includes('time')) {\n    nextPhase = 'objection_need_time';\n    currentState.objections_handled.push('time');\n  }\n}\n// Objection: Call later / Busy\nelse if (text.includes('call') && (text.includes('later') || text.includes('back') || text.includes('tomorrow') || text.includes('monday') || text.includes('evening') || text.includes('morning'))) {\n  nextPhase = 'objection_callback';\n  // Extract callback time\n  if (text.includes('evening')) capturedData.callback_time = 'evening';\n  else if (text.includes('morning')) capturedData.callback_time = 'morning';\n  else if (text.includes('tomorrow')) capturedData.callback_time = 'tomorrow';\n  else if (text.includes('monday')) capturedData.callback_time = 'monday';\n  capturedData.needs_callback = true;\n}\n// Objection: Prefer live classes\nelse if (text.includes('live') && (text.includes('class') || text.includes('session')) && (text.includes('prefer') || text.includes('want') || text.includes('better'))) {\n  if (!currentState.objections_handled.includes('live_class')) {\n    nextPhase = 'objection_live_class';\n    currentState.objections_handled.push('live_class');\n  }\n}\n// Objection: Price concern\nelse if (text.includes('price') || text.includes('cost') || text.includes('expensive') || text.includes('afford') || text.includes('budget') || (text.includes('how much') && text.includes('fee'))) {\n  if (!currentState.objections_handled.includes('price')) {\n    nextPhase = 'objection_price';\n    currentState.objections_handled.push('price');\n  }\n}\n// Objection: Will learn from YouTube/Free\nelse if (text.includes('youtube') || text.includes('free') || (text.includes('online') && text.includes('learn'))) {\n  if (!currentState.objections_handled.includes('youtube')) {\n    nextPhase = 'objection_youtube';\n    currentState.objections_handled.push('youtube');\n  }\n}\n// Not interested / End call\nelse if (text.includes('not interested') || text.includes('no thanks') || text.includes('don\\'t want')) {\n  nextPhase = 'objection_not_interested';\n}\n\n// ============ PHASE: OPENING ============\nif (!nextPhase && currentState.phase === 'opening') {\n  // Detect domain early\n  const domain = detectDomain(text);\n  if (domain) {\n    currentState.domain = domain;\n    capturedData.domain = domain;\n  }\n  \n  if (text.includes('good') || text.includes('great') || text.includes('loved') || text.includes('amazing') || text.includes('helpful') || text.includes('excellent') || text.includes('nice')) {\n    nextPhase = 'connection_liked';\n  } else if (text.includes('okay') || text.includes('fine') || text.includes('alright') || text.includes('decent')) {\n    nextPhase = 'connection_neutral';\n  } else if (text.includes('not good') || text.includes('bad') || text.includes(\"didn't like\") || text.includes(\"don't remember\") || text.includes('boring') || text.includes('waste')) {\n    nextPhase = 'connection_dislike';\n  } else {\n    // If they just say \"yes\" or \"yeah\" or give short answer, probe more\n    nextPhase = 'connection_probe';\n  }\n}\n\n// ============ PHASE: CONNECTION RESPONSE ============\nelse if (!nextPhase && currentState.phase.startsWith('connection_')) {\n  // Detect domain if not already detected\n  const domain = detectDomain(text);\n  if (domain && !currentState.domain) {\n    currentState.domain = domain;\n    capturedData.domain = domain;\n  }\n  nextPhase = 'situation_role';\n}\n\n// ============ PHASE: SITUATION (Role, Experience, etc.) ============\nelse if (!nextPhase && currentState.phase === 'situation_role') {\n  capturedData.role_description = text;\n  \n  // Detect domain from role\n  const domain = detectDomain(text);\n  if (domain) {\n    currentState.domain = domain;\n    capturedData.domain = domain;\n  }\n  \n  // Detect if student or working\n  if (text.includes('student') || text.includes('studying') || text.includes('pursuing') || text.includes('college') || text.includes('university')) {\n    capturedData.profile_type = 'student';\n    nextPhase = 'situation_student_year';\n  } else if (text.includes('working') || text.includes('job') || text.includes('company') || text.includes('employed')) {\n    capturedData.profile_type = 'working';\n    nextPhase = 'situation_experience';\n  } else {\n    // Check for experience mentioned\n    const exp = extractExperience(text);\n    if (exp) {\n      capturedData.experience_years = exp.years;\n      capturedData.profile_type = 'working';\n      nextPhase = 'situation_ai_usage';\n    } else {\n      nextPhase = 'situation_experience';\n    }\n  }\n}\nelse if (!nextPhase && currentState.phase === 'situation_student_year') {\n  capturedData.student_year = text;\n  nextPhase = 'situation_intent';\n}\nelse if (!nextPhase && currentState.phase === 'situation_experience') {\n  const exp = extractExperience(text);\n  if (exp) {\n    capturedData.experience_years = exp.years;\n  }\n  nextPhase = 'situation_ai_usage';\n}\nelse if (!nextPhase && currentState.phase === 'situation_ai_usage') {\n  capturedData.uses_ai = text.includes('yes') || text.includes('using') || text.includes('chatgpt') || text.includes('gemini') || text.includes('claude') || text.includes('copilot');\n  \n  // Based on profile, go to appropriate pain discovery\n  if (capturedData.profile_type === 'student') {\n    nextPhase = 'pain_career';\n  } else {\n    nextPhase = 'pain_job_market';\n  }\n}\nelse if (!nextPhase && currentState.phase === 'situation_intent') {\n  // What's their main intent - job, passive income, upskilling\n  capturedData.intent = text;\n  if (text.includes('job') || text.includes('placement') || text.includes('career')) {\n    capturedData.primary_goal = 'job';\n  } else if (text.includes('income') || text.includes('money') || text.includes('earn') || text.includes('side hustle') || text.includes('freelance')) {\n    capturedData.primary_goal = 'passive_income';\n  } else if (text.includes('learn') || text.includes('skill') || text.includes('upskill')) {\n    capturedData.primary_goal = 'upskilling';\n  }\n  nextPhase = 'pain_career';\n}\n\n// ============ PHASE: PAIN POINTS ============\nelse if (!nextPhase && currentState.phase === 'pain_job_market') {\n  capturedData.job_market_concern = text;\n  nextPhase = 'pain_challenges';\n}\nelse if (!nextPhase && currentState.phase === 'pain_career') {\n  capturedData.career_concern = text;\n  nextPhase = 'pain_challenges';\n}\nelse if (!nextPhase && currentState.phase === 'pain_challenges') {\n  capturedData.biggest_challenge = text;\n  nextPhase = 'goals_success';\n}\n\n// ============ PHASE: GOALS ============\nelse if (!nextPhase && currentState.phase === 'goals_success') {\n  capturedData.success_definition = text;\n  nextPhase = 'goals_preference';\n}\nelse if (!nextPhase && currentState.phase === 'goals_preference') {\n  if (text.includes('hike') || text.includes('salary') || text.includes('promotion') || text.includes('switch')) {\n    capturedData.preference = 'career_growth';\n  } else if (text.includes('side') || text.includes('income') || text.includes('freelance') || text.includes('business')) {\n    capturedData.preference = 'side_income';\n  } else if (text.includes('job') || text.includes('placement')) {\n    capturedData.preference = 'job_placement';\n  }\n  // Qualify and move to presentation or closing\n  nextPhase = 'presentation_overview';\n}\n\n// ============ PHASE: PRESENTATION ============\nelse if (!nextPhase && currentState.phase === 'presentation_overview') {\n  // After overview, check for questions or move forward\n  if (text.includes('?') || text.includes('what') || text.includes('how') || text.includes('which')) {\n    nextPhase = 'presentation_details';\n  } else if (text.includes('okay') || text.includes('got it') || text.includes('understand')) {\n    nextPhase = 'presentation_benefits';\n  } else {\n    nextPhase = 'presentation_benefits';\n  }\n}\nelse if (!nextPhase && currentState.phase === 'presentation_details') {\n  // They asked questions, now continue\n  nextPhase = 'presentation_benefits';\n}\nelse if (!nextPhase && currentState.phase === 'presentation_benefits') {\n  // Move to closing\n  nextPhase = qualifyLead(capturedData, currentState);\n}\n\n// ============ CLOSING PHASES ============\nelse if (!nextPhase && currentState.phase.startsWith('closing_')) {\n  // Check for positive closing signals\n  if (text.includes('interested') || text.includes('join') || text.includes('enroll') || text.includes('sign up') || text.includes('register')) {\n    nextPhase = 'closing_payment';\n  } else if (text.includes('think') || text.includes('decide') || text.includes('later')) {\n    nextPhase = 'closing_followup';\n  }\n}\nelse if (!nextPhase && currentState.phase === 'closing_payment') {\n  nextPhase = 'closing_complete';\n}\n\n// ============ OBJECTION RESPONSE PHASES ============\nelse if (!nextPhase && currentState.phase === 'objection_family') {\n  // After handling family objection, offer to hold slot\n  nextPhase = 'followup_schedule';\n}\nelse if (!nextPhase && currentState.phase === 'objection_exams') {\n  // After explaining self-paced nature\n  nextPhase = 'presentation_flexibility';\n}\nelse if (!nextPhase && currentState.phase === 'objection_need_time') {\n  // Extract when they can decide\n  if (text.includes('today') || text.includes('evening') || text.includes('tonight')) {\n    capturedData.decision_by = 'today_evening';\n  } else if (text.includes('tomorrow')) {\n    capturedData.decision_by = 'tomorrow';\n  } else if (text.includes('monday') || text.includes('next week')) {\n    capturedData.decision_by = 'next_week';\n  }\n  nextPhase = 'followup_schedule';\n}\nelse if (!nextPhase && currentState.phase === 'objection_callback') {\n  nextPhase = 'followup_confirm';\n}\nelse if (!nextPhase && currentState.phase === 'objection_live_class') {\n  // Explained live + self-paced nature\n  nextPhase = currentState.data.previous_phase || 'presentation_overview';\n}\nelse if (!nextPhase && currentState.phase === 'objection_price') {\n  // After explaining EMI and discounts\n  nextPhase = currentState.sentiment === 'positive' ? 'closing_warm' : 'followup_schedule';\n}\nelse if (!nextPhase && currentState.phase === 'objection_youtube') {\n  // After explaining structured learning value\n  nextPhase = 'presentation_benefits';\n}\nelse if (!nextPhase && currentState.phase === 'presentation_flexibility') {\n  // After explaining flexibility for exams\n  nextPhase = currentState.sentiment === 'positive' ? 'closing_warm' : 'followup_schedule';\n}\n\n// ============ FOLLOWUP PHASES ============\nelse if (!nextPhase && currentState.phase === 'followup_schedule') {\n  // Extract callback time if mentioned\n  if (text.includes('evening')) capturedData.callback_time = 'evening';\n  else if (text.includes('morning')) capturedData.callback_time = 'morning';\n  else if (text.includes('tomorrow')) capturedData.callback_time = 'tomorrow';\n  else if (text.includes('noon') || text.includes('12')) capturedData.callback_time = 'tomorrow_noon';\n  nextPhase = 'followup_confirm';\n}\nelse if (!nextPhase && currentState.phase === 'followup_confirm') {\n  // Schedule confirmed, end gracefully\n  capturedData.followup_scheduled = true;\n  nextPhase = 'closing_scheduled';\n}\n\n// ============ LEAD QUALIFICATION ============\nfunction qualifyLead(data, state) {\n  const years = data.experience_years || 0;\n  const isWorking = data.profile_type === 'working';\n  const isStudent = data.profile_type === 'student';\n  const hasPain = data.biggest_challenge || data.career_concern || data.job_market_concern;\n  const sentiment = state.sentiment;\n  const objectionCount = state.objections_handled.length;\n  \n  // HOT: Working professional 3+ years, positive sentiment, few objections\n  if (years >= 3 && isWorking && sentiment === 'positive' && objectionCount <= 1) {\n    return 'closing_hot';\n  }\n  // HOT: Student final year, very interested\n  if (isStudent && sentiment === 'positive' && (data.primary_goal === 'job' || data.primary_goal === 'passive_income')) {\n    return 'closing_hot';\n  }\n  // WARM: Working professional 1+ years OR interested student\n  if ((years >= 1 && isWorking) || (isStudent && sentiment !== 'negative')) {\n    return 'closing_warm';\n  }\n  // COLD: Just exploring or negative sentiment\n  return 'closing_cold';\n}\n\n// ============ CONTEXT INJECTION ============\n// Add domain-specific context for AI\nif (currentState.domain && domainTools[currentState.domain]) {\n  contextToInject = `Relevant AI tools for ${currentState.domain}: ${domainTools[currentState.domain].join(', ')}`;\n}\n\n// Add urgency context after certain turns\nif (currentState.turn_count >= 8 && !capturedData.urgency_mentioned) {\n  contextToInject += ' [INJECT URGENCY: Only 5 discounted slots remaining]';\n  capturedData.urgency_mentioned = true;\n}\n\n// Track previous phase for objection recovery\nif (nextPhase && nextPhase.startsWith('objection_')) {\n  currentState.data.previous_phase = currentState.phase;\n}\n\n// Update state\nif (nextPhase) {\n  callStates[callId] = { \n    phase: nextPhase, \n    data: capturedData,\n    turn_count: currentState.turn_count,\n    sentiment: currentState.sentiment,\n    domain: currentState.domain,\n    objections_handled: currentState.objections_handled\n  };\n  staticData.callStates = callStates;\n}\n\nreturn {\n  call_uuid: callId,\n  transcript: text,\n  current_phase: currentState.phase,\n  next_phase: nextPhase,\n  captured_data: capturedData,\n  sentiment: currentState.sentiment,\n  domain: currentState.domain,\n  turn_count: currentState.turn_count,\n  context: contextToInject,\n  should_inject: nextPhase !== null\n};"
      },
      "id": "analyze-intent",
      "name": "Analyze Intent (State Machine)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 520]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "should-inject",
              "leftValue": "={{ $json.should_inject }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-inject",
      "name": "Should Inject?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [900, 520]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=http://34.93.142.172:3001/call/inject/{{ $json.call_uuid }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  \"phase\": $json.next_phase,\n  \"context\": $json.context || \"\",\n  \"data\": $json.captured_data,\n  \"sentiment\": $json.sentiment,\n  \"domain\": $json.domain\n}) }}",
        "options": {}
      },
      "id": "inject-phase",
      "name": "Inject Phase",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1120, 460]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "conv-call-ended",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "call-ended-webhook",
      "name": "Call Ended Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 740],
      "webhookId": "conv-call-ended"
    },
    {
      "parameters": {
        "jsCode": "// Process call end - Enhanced summary with learnings from real calls\nconst data = $input.first().json.body;\nconst callId = data.call_uuid;\n\n// Get final state from static data\nconst staticData = $getWorkflowStaticData('global');\nconst callStates = staticData.callStates || {};\nconst finalState = callStates[callId] || { phase: 'unknown', data: {}, sentiment: 'neutral', domain: null, turn_count: 0, objections_handled: [] };\n\n// Determine lead type from final state\nlet leadType = 'cold';\nlet followupPriority = 'low';\n\nif (finalState.phase === 'closing_hot' || finalState.phase === 'closing_payment') {\n  leadType = 'hot';\n  followupPriority = 'immediate';\n} else if (finalState.phase === 'closing_warm' || finalState.sentiment === 'positive') {\n  leadType = 'warm';\n  followupPriority = 'high';\n} else if (finalState.phase === 'closing_scheduled' || finalState.data.followup_scheduled) {\n  leadType = 'scheduled';\n  followupPriority = 'scheduled';\n} else if (finalState.sentiment === 'negative' || finalState.phase === 'objection_not_interested') {\n  leadType = 'cold';\n  followupPriority = 'none';\n}\n\n// Calculate engagement score\nconst engagementScore = Math.min(100, (finalState.turn_count * 5) + (finalState.sentiment === 'positive' ? 30 : 0) + (finalState.data.experience_years ? 10 : 0) + (finalState.domain ? 10 : 0));\n\n// Build action items\nconst actionItems = [];\nif (finalState.data.callback_time) {\n  actionItems.push(`Schedule callback: ${finalState.data.callback_time}`);\n}\nif (finalState.data.has_exams) {\n  actionItems.push(`Note: Has exams till ${finalState.data.exam_end_date || 'date unknown'} - follow up after`);\n}\nif (finalState.objections_handled.length > 0) {\n  actionItems.push(`Objections handled: ${finalState.objections_handled.join(', ')}`);\n}\n\n// Clean up state\ndelete callStates[callId];\nstaticData.callStates = callStates;\n\nreturn {\n  call_uuid: callId,\n  caller_phone: data.caller_phone,\n  duration_seconds: data.duration_seconds,\n  transcript: data.transcript,\n  timestamp: data.timestamp,\n  \n  // Lead Classification\n  lead_type: leadType,\n  followup_priority: followupPriority,\n  engagement_score: engagementScore,\n  \n  // Call Analytics\n  final_phase: finalState.phase,\n  total_turns: finalState.turn_count,\n  sentiment: finalState.sentiment,\n  domain_detected: finalState.domain,\n  objections_handled: finalState.objections_handled,\n  \n  // Captured Data\n  captured_data: finalState.data,\n  \n  // Action Items\n  action_items: actionItems,\n  \n  // CRM Summary\n  summary: {\n    name: finalState.data.name || data.caller_phone,\n    profile_type: finalState.data.profile_type || 'Unknown',\n    domain: finalState.domain || 'General',\n    role: finalState.data.role_description || 'Unknown',\n    experience_years: finalState.data.experience_years || 0,\n    primary_goal: finalState.data.primary_goal || 'Not captured',\n    pain_point: finalState.data.biggest_challenge || finalState.data.career_concern || 'Not captured',\n    lead_type: leadType,\n    callback_time: finalState.data.callback_time || null,\n    notes: `Sentiment: ${finalState.sentiment}, Turns: ${finalState.turn_count}, Objections: ${finalState.objections_handled.join(', ') || 'None'}`\n  }\n};"
      },
      "id": "process-call-end",
      "name": "Process Call End",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 740]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "is-hot",
              "leftValue": "={{ $json.lead_type }}",
              "rightValue": "hot",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-hot-lead",
      "name": "Is Hot Lead?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 740]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "is-scheduled",
              "leftValue": "={{ $json.lead_type }}",
              "rightValue": "scheduled",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-scheduled",
      "name": "Is Scheduled?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [900, 800]
    },
    {
      "parameters": {
        "jsCode": "// HOT LEAD - Immediate action required\nconst data = $input.first().json;\n\n// TODO: Integrate with your CRM/calendar system\n// Example: Google Calendar API, HubSpot, etc.\n\nreturn {\n  action: 'immediate_callback',\n  priority: 'HIGH',\n  lead_type: 'HOT',\n  data: data.summary,\n  engagement_score: data.engagement_score,\n  message: `ðŸ”¥ HOT LEAD: ${data.summary.name}\\nProfile: ${data.summary.profile_type} - ${data.summary.domain}\\nExperience: ${data.summary.experience_years} years\\nGoal: ${data.summary.primary_goal}\\nPain: ${data.summary.pain_point}\\nEngagement: ${data.engagement_score}%`,\n  action_items: data.action_items\n};"
      },
      "id": "handle-hot-lead",
      "name": "Handle Hot Lead",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 680]
    },
    {
      "parameters": {
        "jsCode": "// SCHEDULED CALLBACK - Add to calendar\nconst data = $input.first().json;\n\n// Calculate callback datetime based on captured time\nlet callbackDate = new Date();\nconst callbackTime = data.summary.callback_time;\n\nif (callbackTime === 'tomorrow') {\n  callbackDate.setDate(callbackDate.getDate() + 1);\n  callbackDate.setHours(11, 0, 0);\n} else if (callbackTime === 'tomorrow_noon') {\n  callbackDate.setDate(callbackDate.getDate() + 1);\n  callbackDate.setHours(12, 0, 0);\n} else if (callbackTime === 'evening') {\n  callbackDate.setHours(19, 0, 0);\n} else if (callbackTime === 'morning') {\n  callbackDate.setDate(callbackDate.getDate() + 1);\n  callbackDate.setHours(10, 0, 0);\n} else if (callbackTime === 'monday') {\n  // Find next Monday\n  const daysUntilMonday = (8 - callbackDate.getDay()) % 7 || 7;\n  callbackDate.setDate(callbackDate.getDate() + daysUntilMonday);\n  callbackDate.setHours(11, 0, 0);\n}\n\nreturn {\n  action: 'schedule_callback',\n  priority: 'SCHEDULED',\n  lead_type: 'SCHEDULED',\n  callback_datetime: callbackDate.toISOString(),\n  callback_time_readable: callbackDate.toLocaleString('en-IN', { \n    weekday: 'long', \n    year: 'numeric', \n    month: 'long', \n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit'\n  }),\n  data: data.summary,\n  message: `ðŸ“… CALLBACK SCHEDULED: ${data.summary.name}\\nTime: ${callbackTime}\\nProfile: ${data.summary.profile_type}\\nNotes: ${data.summary.notes}`,\n  action_items: data.action_items\n};"
      },
      "id": "handle-scheduled",
      "name": "Handle Scheduled Callback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 740]
    },
    {
      "parameters": {
        "jsCode": "// WARM/COLD LEAD - Log for nurture sequence\nconst data = $input.first().json;\n\nconst isWarm = data.lead_type === 'warm';\n\nreturn {\n  action: isWarm ? 'nurture_sequence' : 'archive',\n  priority: isWarm ? 'MEDIUM' : 'LOW',\n  lead_type: data.lead_type.toUpperCase(),\n  data: data.summary,\n  engagement_score: data.engagement_score,\n  message: `${isWarm ? 'ðŸŸ¡' : 'âšª'} ${data.lead_type.toUpperCase()} LEAD: ${data.summary.name}\\nProfile: ${data.summary.profile_type}\\nDomain: ${data.summary.domain}\\nSentiment: ${data.sentiment}\\nEngagement: ${data.engagement_score}%`,\n  next_action: isWarm ? 'Add to email nurture sequence' : 'Archive for future reference',\n  action_items: data.action_items\n};"
      },
      "id": "handle-other-lead",
      "name": "Handle Warm/Cold Lead",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 860]
    }
  ],
  "connections": {
    "Start Call Trigger": {
      "main": [
        [
          {
            "node": "Start Conversational Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start Conversational Call": {
      "main": [
        [
          {
            "node": "Respond - Call Started",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transcript Webhook": {
      "main": [
        [
          {
            "node": "Filter User Speech",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter User Speech": {
      "main": [
        [
          {
            "node": "Analyze Intent (State Machine)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Intent (State Machine)": {
      "main": [
        [
          {
            "node": "Should Inject?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Inject?": {
      "main": [
        [
          {
            "node": "Inject Phase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Ended Webhook": {
      "main": [
        [
          {
            "node": "Process Call End",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Call End": {
      "main": [
        [
          {
            "node": "Is Hot Lead?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Hot Lead?": {
      "main": [
        [
          {
            "node": "Handle Hot Lead",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Is Scheduled?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Scheduled?": {
      "main": [
        [
          {
            "node": "Handle Scheduled Callback",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Warm/Cold Lead",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": {
    "global": {
      "callStates": {}
    }
  },
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "3",
  "triggerCount": 0,
  "tags": [
    {
      "name": "FWAI",
      "id": "1"
    },
    {
      "name": "Voice AI",
      "id": "2"
    },
    {
      "name": "Conversational",
      "id": "3"
    }
  ]
}
